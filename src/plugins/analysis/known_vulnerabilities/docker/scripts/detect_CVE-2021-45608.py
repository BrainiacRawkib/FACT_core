
def is_SoftwareBus_dispatchNormalEPMsgOut(func):
    if func.getName() == "SoftwareBus_dispatchNormalEPMsgOut":
        return True
    return False

# Returns addresses of kmalloc calls in a list.


def find_kmalloc_calls_in_function(func):
    addr = list()
    called = func.getCalledFunctions(monitor)

    for call in called.iterator():
        if call.getName() == "__kmalloc":
            for ref in getReferencesTo(call.getEntryPoint()):
                if func.getBody().contains(ref.getFromAddress()):
                    print("found __kmalloc call @ {}".format(ref.getFromAddress()))
                    addr.append(ref.getFromAddress())
    return addr


def get_decompiler():
    flat_api = ghidra.program.flatapi.FlatProgramAPI(
        getCurrentProgram(), getMonitor())
    decompiler_api = ghidra.app.decompiler.flatapi.FlatDecompilerAPI(flat_api)
    decompiler_api.initialize()
    return decompiler_api.getDecompiler()

# Returns Pcode representation of a block, for debugging.


def get_pcode_mnemonics(block):
    result = {}
    for op in block.getIterator():
        mnemonic = op.getMnemonic()
        result.setdefault(mnemonic, 0)
        result[mnemonic] += 1
    return result

# Retruns the basic blocks of a function.


def get_function_blocks(function):
    decompiler = get_decompiler()
    function_decompiler = decompiler.decompileFunction(
        function, 120, getMonitor())
    high_function = function_decompiler.getHighFunction()

    return [block for block in high_function.getBasicBlocks()]

# Retruns the indexes of basic blocks before the provided block.


def get_block_in_indexes(block):
    return [
        block.getIn(i).getIndex()
        for i in range(block.getInSize())
    ]

# Returns blocks containing a kmalloc call.


def find_blocks_with_kmalloc_call(blocks, kmalloc_calls):
    blocks_with_kmalloc = list()
    for block in blocks:
        for kmalloc_call in kmalloc_calls:
            if block.contains(kmalloc_call):
                blocks_with_kmalloc.append(block)
    print("kmalloc call(s) in basic blocks: {}".format(
        [i.getIndex() for i in blocks_with_kmalloc]))
    return blocks_with_kmalloc

# Checks if a basic block contains a INT_LESS instruction and includes the magic number 0x1000000


def is_less_than_branch(block):
    pcodes = list(block.getIterator())
    if pcodes[0].getMnemonic() == "INT_LESS":
        operants = pcodes[0].getInputs()
        for op in operants:
            if op.isConstant() and (op.getAddress().getOffset() == 0x1000000):
                return True
    return False


def main():
    print("Program Info:")
    print("{} LangID: {}, CompilerSpec: {}".format(currentProgram.getName(
    ), currentProgram.getLanguageID(), currentProgram.getCompilerSpec().getCompilerSpecID()))

    print("Searching for CVE-2021-45608 related function: SoftwareBus_dispatchNormalEPMsgOut...")
    function = getFirstFunction()
    while function is not None:
        if is_SoftwareBus_dispatchNormalEPMsgOut(function):
            print("found " + function.getName() + " at " +
                  function.getEntryPoint().toString())
            break
        function = getFunctionAfter(function)

    # Errorcase
    if function is None:
        print("cloud not find function.")
        return

    # find kmalloc calls within function
    kmalloc_addresses = find_kmalloc_calls_in_function(function)

    # find basic blocks containing kmalloc calls
    blocks = get_function_blocks(function)
    blocks_with_kmalloc_call = find_blocks_with_kmalloc_call(
        blocks, kmalloc_addresses)
    parents = list()
    for block in blocks_with_kmalloc_call:
        parents.extend(get_block_in_indexes(block))
    print("found parent blocks: {}".format(parents))

    # check parent blocks for fix
    print("check if parent blocks contain the fix...")
    for block in blocks:
        if block.getIndex() in parents:
            if is_less_than_branch(block):
                print("NOT VULNERABLE! Fix detected.")


if __name__ == '__main__':
    main()
